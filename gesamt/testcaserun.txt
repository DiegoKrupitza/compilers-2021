Teste "make clean"
rm -f gesamt codegen.c *.o oxout.* lex.yy.c y.tab.* y.output parser
codeb: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=fdfd3fc54de28bf17a5fd3518b74e3cf6937a0b5, not stripped
codeb is object or executable
Teste "make"
ox parser.y scanner.l
ox: parser.y: warning: line 240: implicit dependent depends on itself
ox: parser.y: warning: line 250: implicit dependent depends on itself
flex oxout.l
yacc -d -v oxout.y
gcc -c lex.yy.c  
gcc -c y.tab.c	
gcc -g -c -pedantic -Wall list.c
gcc -g -c -pedantic -Wall implemented_meth_list.c
gcc -g -c -pedantic -Wall class_var_list.c
gcc -g -c -pedantic -Wall code_injection.c
gcc -g -c -pedantic -Wall tree.c
gcc -g -c -pedantic -Wall code_generator.c
bfe < codegen.bfe | iburg > codegen.c
gcc -g -c -pedantic -Wall codegen.c
gcc -g list.o tree.o codegen.o class_var_list.o implemented_meth_list.o code_injection.o code_generator.o y.tab.o lex.yy.o -ll -o gesamt
==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a0.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 6 && c.f(0,-3)==-3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a1.0:
interface i: f(int):int end;
interface i2: g(int):int end;
class c implements i i2:
 method g(x:int) return x; end;
 method f(x:int) return 1; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
.quad c_g
class_size_c_class = 8


c_g:
	movq	%rsi, %rax
	ret
c_f:
	movq	$1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft {
  long (*f)(struct objectc *, long);
  long (*g)(struct objectc *, long);
} c;
RET(c.g(0,6) == 6 && c.g(0,-3)==-3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a2.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 4; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	$4, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 4 && c.f(0,-3)==4);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a3.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 4; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	$4, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 4 && c.f(0,-3)==4);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a4.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return not x; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	notq	%rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == ~6L && c.f(0,-3)==~-3L);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a5.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 1+x+2; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %r11
	addq	$2, %r11
	addq	$1, %r11
	movq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 9 && c.f(0,-3)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a6.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 2*x*3; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %r11
	imulq	$3, %r11
	imulq	$2, %r11
	movq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 36 && c.f(0,-3)==-18);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a7.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int, y:int) return x and y; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	movq	%rdx, %r11
	and	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,5,3) == 1 && c.f(0,-3L,-5L)==-7L);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a8.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int, y:int) return y-x; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rdx, %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,5,3) == -2L && c.f(0,-3L,3L)==6L);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/a9.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int, y:int) return x<y; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,1,-1L) == 0 && c.f(0,-3L,3L)==-1L && c.f(0,1,1)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/aa.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int, y:int) return x=y; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax equals r11
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,1,-1L) == 0 && c.f(0,-3L,3L)==0 && c.f(0,1,1)==-1L);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/ab.0:
interface i: f(int):i end;
class c implements i:
 method f() return this; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rdi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { struct objectc *(*f)(struct objectc *); } c;
struct objectc o = { &c };
RET(c.f(&o) == &o);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/ac.0:
interface i: f(int):int end;
class c implements i:
 var v:int;
 method f() return v; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 16


c_f:
	movq	8(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long v; };
extern struct vft { long (*f)(struct objectc *); } c;
struct objectc o = { &c, 9 };
RET(c.f(&o) == 9);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/ad.0:
interface i: f(int):i end;
class c implements i:
 var v:int;
 method f() return null i; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 16


c_f:
	movq	$0, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long v; };
extern struct vft { struct objectc *(*f)(struct objectc *); } c;
struct objectc o = { &c };
RET(c.f(&o) == NULL);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b0.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) var y:int :=x*2; return y+5; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	enter	$8, $0
	movq	%rsi, %rax
	imulq	$2, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	addq	$5, %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 17 && c.f(0,-3)==-1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b1.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) x:=x*2; return x+5; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	imulq	$2, %rax
	movq	%rax, %rsi
	movq	%rsi, %rax
	addq	$5, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 17 && c.f(0,-3)==-1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b2.0:
interface i: f(int):int end;
class c implements i:
 var ov:int;
 method f(x:i) ov:=x+1; return this; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 16


c_f:
	movq	%rsi, %rax
	addq	$1, %rax
	movq	%rax, 8(%rdi)
	movq	%rdi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long ov; } o;
extern struct vft { struct objectc *(*f)(struct objectc *, long); } c;
o.vftc = &c;
RET(c.f(&o,6)->ov == 7 && c.f(&o,-3)->ov==-2);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b3.0:
interface i: even(int):int end;
class c implements i:
 method even(x:int) if (x and 1)=1 then return 0; else return 0-1; end; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_even
class_size_c_class = 8


c_even:
	movq	%rsi, %rax
	and	$1, %rax
	cmpq	$1, %rax	# checking if 1 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_even_0_else
	movq	$0, %rax
	ret
	jmp	label_c_even_0_end

	label_c_even_0_else:
	movq	$1, %r11
	movq	$0, %rax
	subq	%r11, %rax
	ret

	label_c_even_0_end:

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*even)(struct objectc *, long); } c;
RET(c.even(0,6) == -1 && c.even(0,-3)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b4.0:
interface i: sgn(int):int end;
class c implements i:
 method sgn(x:int)
   if x<0 then return 0-1; end;
   if 0<x then return  1; end;
   return 0;
 end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_sgn
class_size_c_class = 8


c_sgn:
	movq	%rsi, %rax
	cmpq	$0, %rax	# checking if 0 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_sgn_0_end
	movq	$1, %r11
	movq	$0, %rax
	subq	%r11, %rax
	ret

	label_c_sgn_0_end:
	movq	%rsi, %r11
	cmpq	$0, %r11	# checking if 0 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_sgn_1_end
	movq	$1, %rax
	ret

	label_c_sgn_1_end:
	movq	$0, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*sgn)(struct objectc *, long); } c;
RET(c.sgn(0,6) == 1 && c.sgn(0,-3)==-1 && c.sgn(0,0)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b5.0:
interface i: fac(int):int end;
class c implements i:
 method fac(x:int)
   var r:int := 1;
   while 0<x do
     r:=r*x;
     x:=x-1;
   end;
   return r;
 end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_fac
class_size_c_class = 8


c_fac:
	enter	$8, $0
	movq	$1, 0(%rsp)

	label_c_fac_0:
	movq	%rsi, %r11
	cmpq	$0, %r11	# checking if 0 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_fac_0_end
	movq	0(%rsp), %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	%rsi, %rax
	subq	$1, %rax
	movq	%rax, %rsi
	jmp	label_c_fac_0

	label_c_fac_0_end:
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*fac)(struct objectc *, long); } c;
RET(c.fac(0,4) == 24 && c.fac(0,0)==1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b6.0:
interface i: fib(int):int end;
class c implements i:
 method fib(n:int)
   var a:int := 0;
   var b:int := 1;
   while 0<n do
     var t:int := a+b;
     a:=b;
     b:=t;
     n:=n-1;
   end;
   return a;
 end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_fib
class_size_c_class = 8


c_fib:
	enter	$24, $0
	movq	$0, 0(%rsp)
	movq	$1, 8(%rsp)

	label_c_fib_0:
	movq	%rsi, %r11
	cmpq	$0, %r11	# checking if 0 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_fib_0_end
	movq	0(%rsp), %rax
	movq	8(%rsp), %r11
	addq	%r11, %rax
	movq	%rax, 16(%rsp)
	movq	8(%rsp), %rax
	movq	%rax, 0(%rsp)
	movq	16(%rsp), %rax
	movq	%rax, 8(%rsp)
	movq	%rsi, %rax
	subq	$1, %rax
	movq	%rax, %rsi
	jmp	label_c_fib_0

	label_c_fib_0_end:
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*fib)(struct objectc *, long); } c;
RET(c.fib(0,4) == 3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b7.0:
interface i: gcd(int,int):int end;
class c implements i:
 method gcd(a:int,b:int)
   while not(a=b) do
     if a<b then b:=b-a; else a:=a-b; end;
   end;
   return a;
 end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_gcd
class_size_c_class = 8


c_gcd:

	label_c_gcd_0:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax equals r11
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	notq	%rax
	cmpq	$0, %rax
	jns	label_c_gcd_0_end
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_gcd_1_else
	movq	%rdx, %rax
	movq	%rsi, %r11
	subq	%r11, %rax
	movq	%rax, %rdx
	jmp	label_c_gcd_1_end

	label_c_gcd_1_else:
	movq	%rsi, %rax
	movq	%rdx, %r11
	subq	%r11, %rax
	movq	%rax, %rsi

	label_c_gcd_1_end:
	jmp	label_c_gcd_0

	label_c_gcd_0_end:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*gcd)(struct objectc *, long, long); } c;
RET(c.gcd(0,21,15) == 3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b8.0:
interface i: f():i end;
class c implements i:
 method f() return new c; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	leaq	c(%rip), %rax
	movq	%rax, (%r15)
	leaq	(%r15), %rax
	addq	$class_size_c_class,%r15
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { struct objectc *(*f)(struct objectc *); } c;
RET(c.f(0)->vftc==&c);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/b9.0:
interface i: f():i end;
class d implements i: var v1:int; var v2:int; method f() return this; end; end;
class c implements i:
 var v3:i;
 method f() v3:=new d; return new c; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl d
d:   
.quad d_f
class_size_d_class = 24



.globl c
c:   
.quad c_f
class_size_c_class = 16


d_f:
	movq	%rdi, %rax
	ret
c_f:
	leaq	d(%rip), %rax
	movq	%rax, (%r15)
	leaq	(%r15), %rax
	addq	$class_size_d_class,%r15
	movq	%rax, 8(%rdi)
	leaq	c(%rip), %rax
	movq	%rax, (%r15)
	leaq	(%r15), %rax
	addq	$class_size_c_class,%r15
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectd { struct vft *vftd; long v1; long v2; };
struct objectc { struct vft *vftc; struct objectd *v3; } o;
extern struct vft { struct objectc *(*f)(struct objectc *); } c, d;
RET(c.f(&o)->vftc==&c && o.v3->vftd==&d);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_000.0:
interface i:
	func(int): int
end;

class d implements i:
	method func(aa: int)
		return aa + 1;
	end;
end;

class c implements i:
	var a : i;
	method func(aa: int)
		a := new d;
		return a.func(aa);
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2934 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/cckski0v.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_000.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_000.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_001.0:
interface i:
	func(int): int
end;

class d implements i:
	method func(aa: int)
		return aa + 1;
	end;
end;

class c implements i:	

		var b : i; 
	method func(aa: int)
		b:=new d;	
		var a : int := aa;	
		var av : int := 13;	
		return   2 + ((0 - 3) +  b.func(a)); 
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2945 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccQl5hmx.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_001.call:4: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_001.call:4: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_002.0:
interface i:
	func(int): int
end;

class d implements i:
	method func(aa: int)
		return aa + 1;
	end;
end;

class c implements i:	

	method func(aa: int)
		var b : i :=new d;	
		var a : int := 12;	
		var av : int := 13;	
		return   a + ((0-av)+  b.func(aa)); 
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2956 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccSym0pD.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_002.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_002.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_003.0:
interface i:
	f1(int): int
	f2(int): int
end;

class d implements i:
	method f2(aa: int)
		return aa + 1;
	end;
end;

class c implements i:	
	var b : i; 

	method f2(aa: int)
		return aa + 1;
	end;

	method f1(aa: int)
		b:=new d;	
		var five : int := b.f2(4); 
		return aa + five;
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2967 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/cceHoTQF.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_003.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_003.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_004.0:
interface i:
	f1(int): int
	f2(): int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		a:= aa;
		return 0;
	end;

	method f2()
		return a;
	end;
end;

class c implements i:	
	var b : i; 

	method f1(aa: int)
		b:=new d;	
		b.f1(aa);
		return   2 * b.f2(); 
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2978 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccFkxxPL.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_004.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_004.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_005.0:
interface i:
	f1(int): int
	f2(): int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		a:= aa;
		return 0;
	end;

	method f2()
		return a;
	end;
end;

class c implements i:	
	method f1(aa: int)
		var b: i :=new d;	
		b.f1(aa);
		return b.f2() * b.f2(); 
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  2989 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccaO43IN.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_005.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_005.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_006.0:
interface i:
	f1(int): int
	f2(int): int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		return aa + (2 * this.f2(aa));
	end;

	method f2(aa: int)
		return aa;
	end;
end;

class c implements i:	

	method f2(aa: int)
		return aa + 1;
	end;

	method f1(aa: int)
		var obj: i := new d;
		return (4 * obj.f1(aa));
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3000 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccAojJVS.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_006.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_006.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_007.0:
interface i:
	f1(int): int
	f2(int): int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		return aa + (2 * this.f2(aa));
	end;

	method f2(aa: int)
		return aa;
	end;
end;

class c implements i:	

	method f2(aa: int)
		return aa + 1;
	end;

	method f1(aa: int)
		var obj: i := new d;
		var val1 : int := obj.f1(aa);
		val1 := val1 + aa;
		return val1 + obj.f1(aa);
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3011 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccIxQBrU.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_007.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_007.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_008.0:
interface i:
	f1(int): int
	f2(int): int
	f3():int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		var b : i := new d;
		b.f2(aa);
		return b;
	end;

	method f2(aa: int)
		a := aa;
		return 0;
	end;

	method f3()
		return a;
	end;
end;

class c implements i:	
	method f1(aa: int)
		var obj: i := new d;
		var newobj : i := obj.f1(aa);
		return newobj.f3();
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3022 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccfwHrC1.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_008.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_008.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_009.0:
interface i:
	f1(int): int
	f2(int): int
	f3():int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		var b : i := new d;
		b.f2(aa);
		return b;
	end;

	method f2(aa: int)
		a := aa;
		return 0;
	end;

	method f3()
		return a;
	end;
end;

class c implements i:	

	method f1(aa: int)
		var obj: i := new d;
		return (obj.f1(aa)).f3();
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3033 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/cczLbS82.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_009.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_009.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_011.0:
interface i:
	f1(int): int
	f2(int): int
	f3():int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		var b : i := new d;
		b.f2(aa);
		return b;
	end;

	method f2(aa: int)
		a := aa;
	end;

	method f3()
		return 41;
	end;
end;

class c implements i:	

	method f1(aa: int)
		return (new d).f3();
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3044 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/cc7kiNc9.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_011.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_011.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_012.0:
interface i:
	f1(int): int
	f2(int): int
	f3():int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		var b : i := new d;
		b.f2(aa);
		return b;
	end;

	method f2(aa: int)
		a := aa + 1;
		return a;
	end;

	method f3()
		return 41;
	end;
end;

class c implements i:	

	method f1(aa: int)
		var obj : i := new d;
		var a : int := 0;
		a := obj.f2(a); /* a++ */
		a := a + 1; /* a++ */
		a := obj.f2(a); /* a++ */
		return a;
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3055 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccZBKmva.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_012.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_012.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_013.0:
interface i:
	f1(int): int
	f2(int): int
	f3():int
end;

class d implements i:
	var a : int;
	method f1(aa: int)
		var b : i := new d;
		b.f2(aa);
		return b;
	end;

	method f2(aa: int)
		a := aa + 1;
		return a;
	end;

	method f3()
		return 41;
	end;
end;

class c implements i:	

	method f1(aa: int)
		var obj : i := new d;
		var a : int := aa;
		a := ((1-1) + obj.f2(a)); /* a++ */
		return a;
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3066 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccec91Cg.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_013.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_013.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_014.0:
interface i:
	func(int): int
end;

class d implements i:
	method func(aa: int)
		return aa + 1;
	end;
end;

class c implements i:
	method func(aa: int)
		var a : int := 5;
		var obj : i := new d;
		var b : int := obj.func(1 +(3 * 1) + 1 + 1);
		return a = b;
	end;
end;

/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3077 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccggPWVh.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_014.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_014.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_016.0:
interface i:
	func(int): int
end;

class fibbo implements i:
	method func(aa: int)
		if aa < 3 then
			return 1;
		end;
		var a : int := this.func(aa - 1);
		var b : int := this.func(aa-2);
		return a + b;
	end;
end;

class c implements i:
	var a : i;
	method func(aa: int)
		a := new fibbo;
		return a.func(aa);
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3088 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccjzYdyk.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_016.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_016.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/fab123_017.0:
interface i:
	func(int): int
	sum(int, int): int
end;

class d implements i:
	method func(aa: int)
		return aa + 1;
	end;
	method sum(aa: int, bb: int)
		return aa + bb;
	end;
end;

class c implements i:
	var a : i;
	method sum(aa: int, bb: int)
		return aa + bb;
	end;
	method func(aa: int)
		a := new d;
		return a.sum(a.func(aa), a.func(aa)); /* aa + 1 + aa + 1*/
	end;
end;


/usr/ftp/pub/ubvl/test/gesamt/test: line 34:  3099 Segmentation fault      $PROGRAM < $i > $RESFILE
Übersetzung: [Errot] Status=139. Erwartet: 0

Ausgabe:

Übersetze und linke das Testprogramm:
/tmp/ccGli1Fe.o: In function `call':
/home/ublu21/u11808206/test/gesamt/fab123_017.call:3: undefined reference to `c'
/home/ublu21/u11808206/test/gesamt/fab123_017.call:3: undefined reference to `c'
collect2: error: ld returned 1 exit status
[Error] Erzeugter Code konnte nicht assembliert und gelinkt werden.
==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-0.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x + 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	addq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 9 && c.f(0,-3)==0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-1.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x - 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	subq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,6) == 3 && c.f(0,-3)==-6);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-10.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    var kingD : int;
    var giveMe : int;

    method f(x:int,y:int) 
        return (kingD * x) + giveMe + 60; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 24


c_f:
	movq	8(%rdi), %rax
	movq	%rsi, %r11
	imulq	%r11, %rax
	movq	16(%rdi), %r11
	addq	$60, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long kingD; long giveMe; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD= 69;
myObj->giveMe = 2;

RET(c.f(myObj,3,10) == 269);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-11.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
.quad c_g
.quad c_h
.quad c_j
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	cmpq	$3, %rax	# checking if 3 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_g:
	movq	%rsi, %r11
	cmpq	$3, %r11	# checking if 3 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_h:
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_j:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.f(0,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-12.0:
interface i: 
    g(int):int 
end;
class c implements i:
    method g(x:int) 
        return 3 < x; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_g
class_size_c_class = 8


c_g:
	movq	%rsi, %r11
	cmpq	$3, %r11	# checking if 3 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*g)(struct objectc *, long); 
} c;
RET(c.g(0,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-13.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
.quad c_g
.quad c_h
.quad c_j
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	cmpq	$3, %rax	# checking if 3 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_g:
	movq	%rsi, %r11
	cmpq	$3, %r11	# checking if 3 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_h:
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_j:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.h(0,3,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-14.0:
interface i: 
    j(int,int):int 
end;
class c implements i:
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_j
class_size_c_class = 8


c_j:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft {
    long (*j)(struct objectc *, long, long);
} c;
RET(c.j(0,3,3) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-15.0:
interface i: 
    f(int):int 
    g(int):int 
    h(int,int):int 
    j(int,int):int 
end;
class c implements i:
    method f(x:int) 
        return x < 3; 
    end;
    method g(x:int) 
        return 3 < x; 
    end;
    method h(x:int,y:int) 
        return y < x; 
    end;
    method j(x:int,y:int) 
        return x < y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
.quad c_g
.quad c_h
.quad c_j
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	cmpq	$3, %rax	# checking if 3 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_g:
	movq	%rsi, %r11
	cmpq	$3, %r11	# checking if 3 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_h:
	movq	%rdx, %rax
	movq	%rsi, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret
c_j:
	movq	%rsi, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { 
    long (*f)(struct objectc *, long); 
    long (*g)(struct objectc *, long); 
    long (*h)(struct objectc *, long, long);
    long (*j)(struct objectc *, long, long);
} c;
RET(c.f(0,2) == -1 && c.g(0,4) == -1  && c.h(0,3,2) == -1  && c.j(0,2,3) == -1  && c.j(0,3,10) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-17.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	$5, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 5 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-18.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        var v2 : int := 10;
        return v2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$16, $0
	movq	$5, 0(%rsp)
	movq	$10, 8(%rsp)
	movq	8(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 10 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-19.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := 5;
        var v2 : int := v1;
        return v2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$16, $0
	movq	$5, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, 8(%rsp)
	movq	8(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == 5 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-2.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x * 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	imulq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == 6 && c.f(0,-1)==-3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-20.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := kingD1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	8(%rdi), %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == myObj->kingD1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-21.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := kingD1 + 1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	8(%rdi), %rax
	addq	$1, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,0,0) == myObj->kingD1 + 1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-22.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := x;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	%rsi, 0(%rsp)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,0) == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-23.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1 : int := x + y ;
        return v1 + 1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	addq	$1, %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 69
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-24.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        x := x + x;
        return x;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %rax
	movq	%rsi, %r11
	addq	%r11, %rax
	movq	%rax, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 100
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-25.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        x := (x + y) < 100;
        return x;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	cmpq	$100, %rax	# checking if 100 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	movq	%rax, %rsi
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == -1
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-26.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := 696942;
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$696942, %rdx
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 696942
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-27.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := x;
        x := y;  /* ha tricked you ;) */
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %rdx
	movq	%rdx, %rsi
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-28.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        y := kingD2;
        x := 10;
        return y;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	16(%rdi), %rdx
	movq	$10, %rsi
	movq	%rdx, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == myObj->kingD2
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-29.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD2 := 10;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$10, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 10 &&
    myObj->kingD2 == 10
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-3.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return x < 3; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	cmpq	$3, %rax	# checking if 3 less rax (inverted because right const not allwoed) 
	setl	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == -1 && c.f(0,-1)==-1 && c.f(0,100) == 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-30.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD2 := ((x + y) * kingD1) * 2;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	movq	8(%rdi), %r11
	imulq	%r11, %rax
	imulq	$2, %rax
	movq	%rax, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == ((50 + 18) * myObj->kingD1) * 2 &&
    myObj->kingD2 == ((50 + 18) * myObj->kingD1) * 2
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-31.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        kingD1 := y;
        kingD2 := x;
        return kingD2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rdx, 8(%rdi)
	movq	%rsi, 16(%rdi)
	movq	16(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50 &&
    myObj->kingD1 == 18 &&
    myObj->kingD2 == 50
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-32.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1: int := 10;
        kingD1 := v1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	$10, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 10 &&
    myObj->kingD1 == 10
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-33.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var v1: int := (x * y) + 10;
        kingD1 := v1;
        kingD2 := v1 + 1;
        return v1;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	%rsi, %rax
	movq	%rdx, %r11
	imulq	%r11, %rax
	addq	$10, %rax
	movq	%rax, 0(%rsp)
	movq	0(%rsp), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	addq	$1, %rax
	movq	%rax, 16(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == (50 * 18) + 10 &&
    myObj->kingD1 == c.h(myObj,50,18) &&
    myObj->kingD2 == c.h(myObj,50,18) + 1 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-34.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        /* switching kingD1 with kingD2 */
        var helper : int := kingD1;
        kingD1 := kingD2;
        kingD2 := helper;
        return helper;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	8(%rdi), %rax
	movq	%rax, 0(%rsp)
	movq	16(%rdi), %rax
	movq	%rax, 8(%rdi)
	movq	0(%rsp), %rax
	movq	%rax, 16(%rdi)
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 69 &&
    myObj->kingD1 == 99 &&
    myObj->kingD2 == 69 
);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-35.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        
        if 0-1 then 
            /* this will be called */
            return 5;
        end;

        return 1;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$1, %r11
	movq	$0, %rax
	subq	%r11, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$5, %rax
	ret

	label_c_h_0_end:
	movq	$1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 5
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-36.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        
        if 0 then 
            return 5;
        end;

        return 1;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$0, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$5, %rax
	ret

	label_c_h_0_end:
	movq	$1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-37.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0-1 then 
            /* this will be called */
            x := 100;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$1, %r11
	movq	$0, %rax
	subq	%r11, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$100, %rsi

	label_c_h_0_end:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-38.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0 then 
            x := 100;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$0, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$100, %rsi

	label_c_h_0_end:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-39.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 0-100 then 
            x := 1;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	$100, %r11
	movq	$0, %rax
	subq	%r11, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$1, %rsi

	label_c_h_0_end:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-4.0:
interface i: f(int):int end;
class c implements i:
 method f(x:int) return 3 < x; end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %r11
	cmpq	$3, %r11	# checking if 3 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long); } c;
RET(c.f(0,2) == 0 && c.f(0,-1)== 0 && c.f(0,100) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-40.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 2<x then 
            x := 1;
        end;

        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %r11
	cmpq	$2, %r11	# checking if 2 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$1, %rsi

	label_c_h_0_end:
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1 &&
    c.h(myObj,-100,18) == -100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-41.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 2<x then 
            x := 1;
            kingD1 := 1<100;
        end;

        kingD2 := 200;


        return x;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %r11
	cmpq	$2, %r11	# checking if 2 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$1, %rsi
	movq	$-1, 8(%rdi)

	label_c_h_0_end:
	movq	$200, 16(%rdi)
	movq	%rsi, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 1 &&
    myObj->kingD2 == 200 &&
    c.h(myObj,-100,18) == -100
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-42.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 

        if 2<x then 
            return x;
        end;

        if 2<y then 
            return y;
        end;

        return x+y;
        
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	movq	%rsi, %r11
	cmpq	$2, %r11	# checking if 2 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	%rsi, %rax
	ret

	label_c_h_0_end:
	movq	%rdx, %r11
	cmpq	$2, %r11	# checking if 2 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_1_end
	movq	%rdx, %rax
	ret

	label_c_h_1_end:
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,50,18) == 50 &&
    c.h(myObj,-100,18) == 18 &&
    c.h(myObj,-1,-1) == -2
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-43.0:
interface i: 
    h(int,int):int 
end;
class c implements i:
    var kingD1 : int;
    var kingD2 : int;

    method h(x:int,y:int) 
        var counter: int := 0;

        while 0<x do
            counter := counter + 1;
            x := x - 1;
        end;
        
        return counter;
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 24


c_h:
	enter	$8, $0
	movq	$0, 0(%rsp)

	label_c_h_0:
	movq	%rsi, %r11
	cmpq	$0, %r11	# checking if 0 less r11
	setg	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	0(%rsp), %rax
	addq	$1, %rax
	movq	%rax, 0(%rsp)
	movq	%rsi, %rax
	subq	$1, %rax
	movq	%rax, %rsi
	jmp	label_c_h_0

	label_c_h_0_end:
	movq	0(%rsp), %rax
	leave
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { 
    struct vft *vftc; 
    long kingD1; 
    long kingD2; 
};

extern struct vft { 
    long (*h)(struct objectc *, long, long);
} c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD1 = 69;
myObj->kingD2 = 99;

RET(
    c.h(myObj,3,18) == 3 &&
    c.h(myObj,0,18) == 0 &&
    c.h(myObj,1,18) == 1 &&
    c.h(myObj,-1,-1) == 0
);
Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-5.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return x + y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,2,1) == 3 && c.f(0,-1,1)== 0 && c.f(0,100,23) == 123);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-6.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return ((x + y) + 1) = y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	addq	$1, %rax
	movq	%rdx, %r11
	cmpq	%rax, %r11	# checking if rax equals r11
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,-1,10) == -1 && c.f(0,123,1)== 0 && c.f(0,-1,23) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-7.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return (x * 2) + y; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	imulq	$2, %rax
	movq	%rdx, %r11
	addq	%r11, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,-1,10) == 8 && c.f(0,123,1)== 247 && c.f(0,23,-1) == 45);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-8.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    method f(x:int,y:int) 
        return (not x); 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 8


c_f:
	movq	%rsi, %rax
	notq	%rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;
RET(c.f(0,0,10) != 0);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/kingD-9.0:
interface i: 
    f(int,int):int 
end;
class c implements i:
    var kingD : int;
    method f(x:int,y:int) 
        return kingD; 
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_f
class_size_c_class = 16


c_f:
	movq	8(%rdi), %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; long kingD; };
extern struct vft { long (*f)(struct objectc *, long, long); } c;

struct objectc *myObj = (struct objectc *)malloc(sizeof(struct objectc));
myObj->kingD = 69;

RET(c.f(myObj,0,10) == 69);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/mansnothot-1.0:
interface ISimpleMemRefTest:
    cmp():int
end;

class SimpleMemRefTest implements ISimpleMemRefTest:
    var objVar1 : int;
    var objVar2 : int;

    method cmp()
        return objVar1 = objVar2;
    end;
end;

Übersetzung: Status korrekt

Ausgabe:

.globl SimpleMemRefTest
SimpleMemRefTest:   
.quad SimpleMemRefTest_cmp
class_size_SimpleMemRefTest_class = 24


SimpleMemRefTest_cmp:
	movq	8(%rdi), %rax
	movq	16(%rdi), %r11
	cmpq	%rax, %r11	# checking if rax equals r11
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectSMRT {
    struct vftSMRT *vftSMRT;
    long objVar1;
    long objVar2;
};

extern struct vftSMRT {
    long (*cmp)(struct objectSMRT *);
} SimpleMemRefTest;

struct objectSMRT *myObj = malloc(sizeof *myObj);
myObj->objVar1 = 5;
myObj->objVar2 = 5;

/* 
actually we just want to check that
not both arguments of assembly cmp are memory references
e.g. "cmpq 8(%rdi), 16(%rdi)" is not allowed (no valid asm)
*/
RET(SimpleMemRefTest.cmp(myObj) == -1);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/svchostdotexe-1.0:
interface i: 
    h(int):int
end;
class c implements i:   
    method h(x:int)
    	if x=1 	then return 2;
    	end;
    	
    	if x=3 	then return 4;
    	end;
    	
    	return 3;
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 8


c_h:
	movq	%rsi, %rax
	cmpq	$1, %rax	# checking if 1 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$2, %rax
	ret

	label_c_h_0_end:
	movq	%rsi, %rax
	cmpq	$3, %rax	# checking if 3 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_1_end
	movq	$4, %rax
	ret

	label_c_h_1_end:
	movq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*h)(struct objectc *, long); } c;
RET(c.h(0,1) == 2 && c.h(0,3)==4 && c.h(0,2)==3);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/svchostdotexe-2.0:
interface i:
    h(int, int):int
end;
class c implements i:
    method h(x:int, y:int)
    	if x=1 	then    if y=5 	then return 4;
    		end;
    	else 	if  y=3 	then return 2;
    		end;
    	end;
    	return 7;
    end;
end;


Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 8


c_h:
	movq	%rsi, %rax
	cmpq	$1, %rax	# checking if 1 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_else
	movq	%rdx, %rax
	cmpq	$5, %rax	# checking if 5 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_1_end
	movq	$4, %rax
	ret

	label_c_h_1_end:
	jmp	label_c_h_0_end

	label_c_h_0_else:
	movq	%rdx, %rax
	cmpq	$3, %rax	# checking if 3 equals rax
	sete	%al
	and	$1, %rax
	imulq	$-1, %rax
	cmpq	$0, %rax
	jns	label_c_h_3_end
	movq	$2, %rax
	ret

	label_c_h_3_end:

	label_c_h_0_end:
	movq	$7, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*h)(struct objectc *, long, long); } c;
RET(c.h(0,1, 5) == 4 && c.h(0,1,6)==7 && c.h(0,2,3)==2 && c.h(0,2,4)==7);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /home/ublu21/u11808206/test/gesamt/svchostdotexe-3.0:
interface i:
    h(int):int
end;
class c implements i:
    method h(x:int)
    	if (0-1) then return 2;
    	end;
    	return 3;
    end;
end;
Übersetzung: Status korrekt

Ausgabe:

.globl c
c:   
.quad c_h
class_size_c_class = 8


c_h:
	movq	$1, %r11
	movq	$0, %rax
	subq	%r11, %rax
	cmpq	$0, %rax
	jns	label_c_h_0_end
	movq	$2, %rax
	ret

	label_c_h_0_end:
	movq	$3, %rax
	ret

Übersetze und linke das Testprogramm:

Rufe folgendes Codefragment auf:
struct objectc { struct vft *vftc; };
extern struct vft { long (*h)(struct objectc *, long); } c;
RET(c.h(0,1) == 2);

Erzeugter Code verhaelt sich bezueglich Signal-Erzeugung wie erwartet
und das Ergebnis des Ausdrucks ist korrekt.

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/x0.1:
#

Ausgabe:
ERROR on line 1 Can not lex the symbol: #
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/x1.1:
interface x: y():int end;
class z implements x:
  method y() return 1 /* */  */

Ausgabe:
ERROR on line 1 Can not lex the symbol: /
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y0.2:
class x implements: end

Ausgabe:
Error parsing line: 1 char: 
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y1.2:
interface i: m(int):int end;
class x implements i: method m(p:int,) end; end;

Ausgabe:
Error parsing line: 1 char: )
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y2.2:
interface i: m(int):int end;
class c implements i: method m(x:int) return x+x*x; end; end;

Ausgabe:
Error parsing line: 1 char: *
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y3.2:
interface i: m(int):int end;
class c implements: method m(x:int) return x-x-x; end; end;

Ausgabe:
Error parsing line: 1 char: -
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y4.2:
interface i: m(int):int end;
class c implements: method m(x:int) return not x=x; end; end;

Ausgabe:
Error parsing line: 1 char: =
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y5.2:
interface i: m(int):int end;
class c implements:
  method m(x:int) if x then return x; else return x; else return x; end; end;
end;

Ausgabe:
Error parsing line: 1 char: else
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y6.2:
interface i: m(int):int end;
class c implements: method m(x:i) return x.m(x,); end; end;

Ausgabe:
Error parsing line: 1 char: )
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y7.2:
interface i: m(int):int end;
class c implements: method m(x:int) return m(x); end; end;

Ausgabe:
Error parsing line: 1 char: (
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y8.2:
interface i: m(int):int end;
class c implements: method m(x:int) x.x:=x; end; end;

Ausgabe:
Error parsing line: 1 char: :=
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/y9.2:
interface i: m(int):int end;
class c implements: method m(x:int) return; end; end;

Ausgabe:
Error parsing line: 1 char: ;
syntax error
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z0.3:
class y implements x: end;

Ausgabe:
Identifier with name 'x' on line 1 is not visible in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z1.3:
interface i: m(int):int m(int):int  end;

Ausgabe:
Identifier 'm' on line 1 conflicts with identifier [m] on line 1
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z2.3:
interface i: m1(int):int m2(int):int  end;
class c implements :
  method m1(x:int) end;
  method m2() return x; end;
end;

Ausgabe:
Identifier with name 'x' on line 1 is not visible(ObjectVar,Var,Param) in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z3.3:
interface i: m(int):int end;
class c implements i:
  method m(x:int)
    if x then var x:int:=0; end;
  end;
end;

Ausgabe:
Identifier 'x' on line 1 conflicts with identifier [x] on line 1
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z4.3:
interface i: m(int):int end;
class c implements :
  method m(x:int) return new c1; end;
end;

Ausgabe:
Identifier with name 'c1' on line 1 is not visible in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z5.3:
interface i: m(int):int end;
class c implements :
  method m(x:int) return new x; end;
end;

Ausgabe:
Identifier with name 'x' on line 1 is not visible in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z6.3:
interface i: m(int):int end;
class c implements :
  method m(x:int) return i; end;
end;

Ausgabe:
Identifier with name 'i' on line 1 is not visible(ObjectVar,Var,Param) in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z7.3:
interface i: m(int):int end;
class c implements m:
  method m(x:int) end;
end;

Ausgabe:
Identifier with name 'm' on line 1 is not visible in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z8.3:
class c implements :
  method m(x:int) end;
end;

Ausgabe:
Identifier with name 'm' on line 1 is not visible in the current scope
Status: korrekt

==========> Eingabe von /usr/ftp/pub/ubvl/test/gesamt/z9.3:
interface i: i(int):int end;

Ausgabe:
Identifier 'i' on line 1 conflicts with identifier [i] on line 1
Status: korrekt

Statistics: 
===========
           109 Tests total
           93 Tests passed
           16 Tests failed
